## 关于 Chat2Graph

Chat2Graph 是一个图原生智能体系统（Graph Native Agentic System），它通过利用图数据结构增强智能体能力。其目标是将图数据库与人工智能深度融合，使其更易于访问和功能更强大。

## 核心后端组件 (`app/core`)

`app/core` 目录包含 Chat2Graph 应用程序的核心逻辑。它组织成以下模块：

*   **`agent`**：此模块包含系统中智能体的核心逻辑，包括 `Leader` 和 `Expert` 智能体。
*   **`common`**：提供应用程序中使用的通用工具、数据结构和辅助函数。
*   **`dal`**：数据抽象层（Data Abstraction Layer），负责与数据库通信。
*   **`env`**：管理应用程序的环境和配置。
*   **`knowledge`**：处理知识库，包括基于向量和图的知识。
*   **`memory`**：实现智能体的分层记忆系统。
*   **`model`**：包含应用程序中使用的数据模型和模式。
*   **`prompt`**：管理用于与语言模型交互的提示。
*   **`reasoner`**：推理引擎，封装了双 LLM 推理机的逻辑。
*   **`sdk`**：软件开发工具包（Software Development Kit），提供用于构建和与智能体交互的工具。
*   **`service`**：包含应用程序的业务逻辑和服务。
*   **`toolkit`**：管理智能体可以使用的工具和动作。
*   **`tracer`**：提供跟踪和日志记录功能。
*   **`workflow`**：定义智能体的工作流和操作符编排。

## 测试 (`test`)

`test` 目录包含应用程序的测试，组织如下：

*   **`benchmark`**：包含用于评估应用程序性能的基准测试。
*   **`example`**：提供用于使用应用程序的示例脚本和代码。
*   **`resource`**：包含测试使用的资源和数据。
*   **`unit`**：包含应用程序各个组件的单元测试。

## 后端设计与架构

Chat2Graph 的后端基于“图原生智能体系统”理念构建，将图计算与人工智能深度融合。这种方法总结为“图+AI”，涵盖两个主要方向：

*   **AI for Graph**：利用 AI（特别是智能体系统）降低图系统的使用门槛并增强用户体验。
*   **Graph for AI**：利用图的关联建模优势，增强智能体的关键能力，如推理、记忆和工具使用，从而减少模型幻觉并提高生成质量。

系统采用“一主多从”（Single-Active-Many-Passive）混合多智能体架构，其中一个 `Leader` 智能体协调任务，多个 `Expert` 智能体协作执行任务。

### 关键架构组件及其设计原则：

1.  **智能体模块 (`app/core/agent`)**：
    *   **核心执行单元**：智能体是基本的执行单元，接收任务（`Job`），执行操作并返回结果。
    *   **组件**：每个智能体都包含一个 `Profile`（身份和能力范围）、一个 `Reasoner`（基于 LLM 的推理引擎）和一个 `Workflow`（任务执行过程）。
    *   **类型**：
        *   **`Leader` 智能体**：专注于复杂任务的任务分解、规划和协调，将子任务分配给适当的 `Expert`。
        *   **`Expert` 智能体**：专注于特定领域的任务处理，具有明确定义的专业边界和执行职责。系统目标是未来支持自动化 `Expert` 生成。

2.  **`Leader` 智能体 (`app/core/agent/leader.py`)**：
    *   **职责**：任务规划、分配、执行和 `Expert` 生命周期管理。
    *   **规划**：采用基于图的规划器，将主任务分解为可执行的 `JobGraph`（一个带有依赖关系的子任务有向无环图）。与线性规划器相比，这能更好地适应执行不确定性。
    *   **分配**：将 `JobGraph` 中的子任务分配给相应的 `Expert`，利用线程池并行执行独立的子任务。
    *   **执行**：使用状态机管理 `Job/SubJob` 和 `Agent` 之间的转换，处理成功、执行错误、输入数据错误以及 `Expert` 认为任务过于复杂的情况，可能导致进一步分解。

3.  **推理器模块 (`app/core/reasoner`)**：
    *   **目的**：与大型语言模型（LLM）交互的核心组件，处理提示、推理任务和工具调用。它提供统一的 LLM 交互接口。
    *   **模型服务 (`ModelService`)**：作为 LLM 交互的底层接口，封装了各种 LLM 平台（例如 OpenAI、Gemini、Claude、Qwen、DeepSeek 兼容 API）的调用细节。它支持使用特定标签格式从 LLM 输出中提取工具调用请求，并自动注入系统服务作为工具参数。
    *   **单模型推理器 (`MonoModelReasoner`)**：依赖单个 LLM 实例完成所有任务处理阶段（理解、思考、工具选择、响应生成）。它配置简单，但对于复杂任务可能存在性能限制。它使用统一的提示模板，带有元认知框架，用于深度思考和集成动作执行。
    *   **双模型推理器 (`DualModelReasoner`)**：采用“思考者”（`Thinker`）LLM 和“行动者”（`Actor`）LLM 协作。`Thinker`（能力更强的 LLM）处理复杂的理解、规划和任务分解，将具体指令传递给 `Actor`。`Actor`（更高效的 LLM）专注于执行指令、工具调用和格式化响应。这种设计优化了任务专业化和增强的工具使用，通过将任务分配给具有不同优势的模型来获得更好的整体性能。它为 `Thinker` 和 `Actor` 使用专门的提示。

4.  **记忆系统 (`app/core/memory`)**：
    *   **目的**：信息存储、检索和管理的核心组件，定义了将原始数据提炼为高级洞察的过程。
    *   **分层架构（受 DIKW 金字塔启发）**：
        *   **L0 (历史)**：消息历史、工具调用记录、系统日志（完全可追溯）。
        *   **L1 (评估)**：过程评估结果、性能指标（质量控制、错误诊断）。
        *   **L2 (经验)**：经验规则、最佳实践、领域知识（决策支持、策略优化）。
        *   **L3 (洞察)**：高级决策模式、战略洞察（高维决策）。
    *   **知识管理**：支持知识提炼（从原始知识到高级知识）、知识钻取（从高级知识到低级细节）和知识扩展（同一级别内的关联，例如 RAG）。
    *   **集成**：记忆系统设计可以容纳知识库（作为垂直领域知识中记忆的专门表达）和环境（作为“当前时刻的外部记忆”）。

5.  **工具包模块 (`app/core/toolkit`)**：
    *   **目的**：通过管理“动作”（`Actions`）和“工具”（`Tools`）的有向图，向 `Operator` 推荐具体的执行指令并实现与外部世界的交互。
    *   **工具图设计**：使用有向图，其中节点是 `Actions`（LLM 的状态/决策点），边表示顺序关系（`Actions` 之间的 `Next` 边）和调用概率（`Actions` 和 `Tools` 之间的 `Call` 边）。
        *   **`Tool`**：独立的、可执行的单元，具有名称、描述、参数模式和执行逻辑。可由 `Reasoner` 调用。
        *   **`Action`**：表示 LLM 的状态或决策点，与一个或多个 `Tools` 相关联。
        *   **`Toolkit`**：组织和管理 `Actions` 和 `Tools` 的有向图，表达调用逻辑和任务流。
    *   **工具包服务 (`ToolkitService`)**：管理 `Toolkit` 实例，通过根据当前 `Action` 探索图并推荐相关的 `Tools` 和 `Actions` 来提供上下文感知的工具推荐。这缩小了 LLM 的搜索空间，提高了准确性和效率。
    *   **实现**：工具和动作最初通过 YAML 配置。计划动态工具注册和通过强化学习进行优化。

6.  **工作流模块 (`app/core/workflow`)**：
    *   **目的**：`Agent`（`Leader` 和 `Expert`）执行任务的核心组件，编排和执行一系列预定义的操作符。
    *   **结构**：将多个操作符组织成一个有向无环图（DAG），明确执行顺序和依赖关系。每个 `Agent` 都内置 `Workflow`，定义其标准操作程序（SOP）。
    *   **`Operator`**：`Workflow` 的基本执行单元。它将带有工具、动作和上下文的 `Job` 封装成一个可执行的 `Task` 对象，然后提交给 `Reasoner` 进行处理。`Operator` 专注于任务准备和分发，依赖 `Reasoner` 进行复杂逻辑和工具交互。
    *   **`Evaluator`**：一个可选的特殊操作符，在工作流执行完成后触发，用于评估结果，分类状态（`SUCCESS`、`EXECUTION_ERROR`、`INPUT_DATA_ERROR`、`JOB_TOO_COMPLICATED_ERROR`），并为后续操作符或专家生成反馈（`lesson`）。
    *   **执行**：`Workflow` 被构建（例如，使用 DB-GPT AWEL），然后由 `Agent` 执行，传递当前的 `Job`、`Reasoner`、先前的 `WorkflowMessage` 和 `lesson`。

7.  **SDK (`app/core/sdk`)**：
    *   **分层设计**：提供一套简洁的 API，用于构建和扩展具有分层架构的智能体系统。高级组件（`Agent`、`Profile`、`Workflow`）定义任务目标和流程，而低级组件（`Operator`、`Reasoner`、`KnowledgeBase`、`Toolkit`）提供执行能力。
    *   **智能体服务 (`Agentic Service`)**：核心服务层，协调各种组件（`MessageService`、`SessionService`、`AgentService`、`JobService`、`ToolkitService`、`ReasonerService`）的初始化、配置和运行时交互。它遵循任务驱动模型。

8.  **YAML 配置**：
    *   **声明式系统设置**：通过分层 YAML 文件支持声明式系统配置，定义应用程序信息、插件、推理器、工具包、操作符、工作流和智能体。
    *   **优点**：外部化复杂设置，无需修改核心代码即可快速适应不同的业务场景，并使用引用机制实现可重用性。`AgenticService.load()` 方法解析这些配置。

9.  **系统环境配置**：
    *   **统一访问**：通过 `SystemEnv` 类管理环境变量，提供统一的配置访问接口。
    *   **优先级**：`.env` 文件 > 操作系统环境变量 > 系统默认值。
    *   **特性**：延迟加载、缓存、自动类型转换、验证和运行时动态修改。
    *   **模型兼容性**：支持与 OpenAI API 标准兼容的 LLM 和嵌入模型（例如 Google Gemini、OpenAI、Anthropic Claude、阿里巴巴通义千问、智谱 GLM、DeepSeek）。

## 开发偏好

本项目在开发过程中遵循以下代码规范和习惯，以确保代码质量、可维护性和团队协作效率：

*   **代码可读性与清晰度**：
    *   代码应易于理解，逻辑清晰。
    *   避免过度复杂的结构，优先选择简洁明了的实现方式。
    *   必要时添加简洁的注释，解释“为什么”这样做，而不是“做了什么”。
*   **类型安全**：
    *   广泛使用类型提示（Type Hinting），以增强代码的健壮性、可读性，并支持静态分析工具进行错误检查。
*   **模块化设计与接口驱动**：
    *   通过抽象基类（ABC）或接口定义，促进模块间的解耦，提高代码的可扩展性和可测试性。
    *   每个模块应职责单一，功能内聚。
*   **结构化日志**：
    *   应用程序应配置结构化日志，以便于调试、监控和问题排查。日志信息应包含足够的上下文。
*   **异步编程**：
    *   对于 I/O 密集型任务，优先采用异步编程（`async`/`await`）以提高系统吞吐量和响应能力。
*   **一致性**：
    *   遵循项目内已有的命名约定、代码格式和设计模式，保持整体代码风格的一致性。
*   **错误处理**：
    *   采用统一且健壮的错误处理机制，明确区分可恢复错误和不可恢复错误，并提供有意义的错误信息。
*   **测试驱动**：
    *   鼓励编写单元测试和集成测试，确保代码的正确性和稳定性。

## 命令

*   **启动应用程序**：主应用程序可以通过 `bin/start.sh` 脚本启动。此脚本还会启动 MCP 工具。
*   **安装依赖**：
    *   后端：`pip install -e .`（来自 `pyproject.toml`）
    *   前端（`web`）：`npm install`
    *   文档（`doc/web`）：`npm install`
*   **运行测试**：`pyproject.toml` 文件表明使用 `pytest` 进行测试。您可能可以使用 `pytest` 命令运行测试。

## 文件结构

*   `app/`：包含核心 Python 应用程序。
*   `bin/`：包含用于管理应用程序的 shell 脚本。
*   `doc/`：包含项目文档。
*   `web/`：包含前端 Web 应用程序。
*   `pyproject.toml`：定义 Python 项目依赖和元数据。
*   `README.md`：提供项目概述。